using AutoMapper;
using Microsoft.EntityFrameworkCore.Metadata;
using Reliable_Reservations.Data.Repos.IRepos;
using Reliable_Reservations.Models;
using Reliable_Reservations.Models.DTOs;
using Reliable_Reservations.Services.IServices;

namespace Reliable_Reservations.Services
{
    public class TimeSlotService : ITimeSlotService
    {
        private readonly ITimeSlotRepository _timeSlotRepository;
        private readonly IOpeningHoursService _openingHoursService;
        private readonly IOpeningHoursRepository _openingHoursRepository;
        private readonly IMapper _mapper;

        public TimeSlotService(ITimeSlotRepository timeSlotRepository, IOpeningHoursService openingHoursService, IOpeningHoursRepository openingHoursRepository, IMapper mapper)
        {
            _timeSlotRepository = timeSlotRepository;
            _openingHoursService = openingHoursService;
            _openingHoursRepository = openingHoursRepository;
            _mapper = mapper;
        }

        public async Task<IEnumerable<TimeSlotDto>> GetAllTimeSlotsAsync()
        {
            var timeSlots = await _timeSlotRepository.GetAllTimeSlots();
            return _mapper.Map<IEnumerable<TimeSlotDto>>(timeSlots);
        }


        public async Task<TimeSlot?> GetExistingTimeSlotAsync(DateTime startTime, DateTime endTime)
        {
            // Fetch a time slot that matches the given start and end times
            return await _timeSlotRepository.GetTimeSlotByTimesAsync(startTime, endTime);
        }


        public async Task<TimeSlotDto> GetTimeSlotByIdAsync(int id)
        {
            var timeSlot = await _timeSlotRepository.GetTimeSlotById(id);

            if (timeSlot == null)
            {
                throw new KeyNotFoundException($"TimeSlot with ID {id} not found.");
            }

            return _mapper.Map<TimeSlotDto>(timeSlot);
        }


        public async Task<IEnumerable<TimeSlotDto>> AutoGenerateTimeSlots(TimeSlotAutoGenerateDto timeSlotAutoGenerateDto)
        {
            if (timeSlotAutoGenerateDto.EndDate <= timeSlotAutoGenerateDto.StartDate)
            {
                throw new InvalidOperationException("End date must be after the start date.");
            }

            var allGeneratedTimeSlots = new List<TimeSlot>();
            var existingTimeSlots = await _timeSlotRepository.GetAllTimeSlots(); // Fetch all time slots to avoid duplicates

            // Fetch all opening hours for the week from the database
            IEnumerable<OpeningHours> openingHoursList = await _openingHoursRepository.GetAllAsync();

            // Create a lookup for existing OpeningHours
            var openingHoursLookup = openingHoursList.ToDictionary(oh => oh.DayOfWeek);

            // Create a lookup for special opening hours
            var specialOpeningHoursLookup = openingHoursList
                .SelectMany(oh => oh.SpecialOpeningHours)
                .ToDictionary(soh => soh.Date, soh => soh);

            var currentDay = timeSlotAutoGenerateDto.StartDate;

            while (currentDay <= timeSlotAutoGenerateDto.EndDate)
            {
                var dayOfWeek = currentDay.DayOfWeek;

                if (openingHoursLookup.TryGetValue(dayOfWeek, out var openingHours))
                {
                    var specialOpeningHours = specialOpeningHoursLookup.GetValueOrDefault(DateOnly.FromDateTime(currentDay));

                    var openTime = specialOpeningHours?.OpenTime ?? openingHours.OpenTime;
                    var closeTime = specialOpeningHours?.CloseTime ?? openingHours.CloseTime;
                    var isClosed = specialOpeningHours?.IsClosed ?? openingHours.IsClosed;

                    if (!isClosed)
                    {
                        // Generate time slots for the current day
                        var generatedTimeSlots = GenerateTimeSlotsForDay(openingHours, openTime, closeTime, timeSlotAutoGenerateDto.SlotDuration, currentDay, timeSlotAutoGenerateDto.EndDate);
                        allGeneratedTimeSlots.AddRange(generatedTimeSlots);
                    }
                }

                currentDay = currentDay.AddDays(1); // Move to the next day
            }

            var newTimeSlots = allGeneratedTimeSlots
                .Where(ts => !existingTimeSlots.Any(existingTs => existingTs.StartTime == ts.StartTime && existingTs.EndTime == ts.EndTime))
                .ToList();

            if (newTimeSlots.Any())
            {
                await _timeSlotRepository.AddMultipleTimeSlots(newTimeSlots);
            }

            return newTimeSlots.Select(ts => new TimeSlotDto
            {
                TimeSlotId = ts.TimeSlotId,
                StartTime = ts.StartTime,
                EndTime = ts.EndTime,
                SlotDuration = ts.SlotDuration
            }).ToList();
        }

        private List<TimeSlot> GenerateTimeSlotsForDay(OpeningHours openingHours, TimeOnly openTime, TimeOnly closeTime, int slotDuration, DateTime startDate, DateTime endDate)
        {
            var timeSlots = new List<TimeSlot>();
            var currentTime = openTime;
            var isNextDay = false;

            while (!isNextDay && currentTime.AddMinutes(slotDuration) <= closeTime)
            {
                var startDateTime = startDate.Date.Add(currentTime.ToTimeSpan());
                var endDateTime = startDate.Date.Add(currentTime.AddMinutes(slotDuration).ToTimeSpan());

                // Check if we've wrapped around to the next day
                if (endDateTime < startDateTime)
                {
                    isNextDay = true;
                    endDateTime = endDateTime.AddDays(1);
                }

                if (endDateTime <= endDate)
                {
                    var timeSlot = new TimeSlot
                    {
                        StartTime = startDateTime,
                        EndTime = endDateTime,
                        SlotDuration = slotDuration,
                        OpeningHoursId = openingHours.OpeningHoursId
                    };
                    timeSlots.Add(timeSlot);
                }

                currentTime = currentTime.AddMinutes(slotDuration);

                // Check if we've wrapped around to the next day
                if (currentTime < openTime)
                {
                    isNextDay = true;
                }
            }

            return timeSlots;
        }




        public async Task<TimeSlotDto> CreateTimeSlotAsync(TimeSlotCreateDto timeSlotCreateDto)
        {
            var timeSlot = _mapper.Map<TimeSlot>(timeSlotCreateDto);

            int timeSlotDuration = (int)(timeSlot.EndTime - timeSlot.StartTime).TotalMinutes;

            if (timeSlotDuration != 60 && timeSlotDuration != 120)
            {
                throw new Exception("TimeSlot duration must be either 60 or 120 minutes.");
            }

            timeSlot.SlotDuration = timeSlotDuration;

            DayOfWeek dayOfWeek = timeSlot.StartTime.DayOfWeek;
            var openingHours = await _openingHoursRepository.GetAllAsync();
            var matchingOpeningHours = openingHours.FirstOrDefault(o => o.DayOfWeek == dayOfWeek);

            if (matchingOpeningHours == null)
            {
                throw new Exception($"No OpeningHours found for the day: {dayOfWeek}");
            }

            timeSlot.OpeningHoursId = matchingOpeningHours.OpeningHoursId;

            await _timeSlotRepository.AddTimeSlot(timeSlot);
            return _mapper.Map<TimeSlotDto>(timeSlot);
        }


        public async Task UpdateTimeSlotAsync(int id, TimeSlotUpdateDto timeSlotUpdateDto)
        {
            var timeSlot = await _timeSlotRepository.GetTimeSlotById(id);
            if (timeSlot != null)
            {
                _mapper.Map(timeSlotUpdateDto, timeSlot);
                await _timeSlotRepository.UpdateTimeSlot(timeSlot);
            }
        }

        public async Task DeleteTimeSlotAsync(int id)
        {

            var timeSlotToDelete = await _timeSlotRepository.GetTimeSlotById(id);

            if (timeSlotToDelete == null)
            {
                throw new Exception($"No timeslot with ID {id} exists in database.");
            }

            await _timeSlotRepository.DeleteTimeSlot(timeSlotToDelete);
        }
    }
}
